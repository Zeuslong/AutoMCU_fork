
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>automcu &#8212; AutoMCU 0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for automcu</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tqdm</span>

<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">spectral</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>


<span class="n">sample_axis</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">band_axis</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="bandwind_from_wls"><a class="viewcode-back" href="../automcu.html#automcu.bandwind_from_wls">[docs]</a><span class="k">def</span> <span class="nf">bandwind_from_wls</span><span class="p">(</span><span class="n">centers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">wl1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">wl2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Given a list of band centers and a pair of floats</span>
<span class="sd">    defining a range of wavelengths, find the bands that are covered by this</span>
<span class="sd">    range (but not outside). Bands are 0-based, so first band is 0&quot;&quot;&quot;</span>
    <span class="c1">##First check if there&#39;s overlap, return None if not</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wl1</span> <span class="o">&gt;</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">wl2</span> <span class="o">&lt;</span> <span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">minband</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">maxband</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">wl1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">wl2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ci</span> <span class="o">&lt;</span> <span class="n">minband</span><span class="p">:</span>
                <span class="n">minband</span> <span class="o">=</span> <span class="n">ci</span>
            <span class="k">if</span> <span class="n">ci</span> <span class="o">&gt;</span> <span class="n">maxband</span><span class="p">:</span>
                <span class="n">maxband</span> <span class="o">=</span> <span class="n">ci</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maxband</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">minband</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)):</span>
        <span class="c1">##Should not get here if there&#39;s overlap, unless wl range is tiny</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">minband</span><span class="p">,</span> <span class="n">maxband</span><span class="p">]</span></div>


<div class="viewcode-block" id="AutoMCU"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU">[docs]</a><span class="k">class</span> <span class="nc">AutoMCU</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to setup and run AutoMCU according to specify configuration</span>
<span class="sd">    Inputs:</span>
<span class="sd">    em_csvs           : List of csv files that contain endmember spectra, one</span>
<span class="sd">                        for each class - typically PV, NPV, and Bare. CSVs</span>
<span class="sd">                        should be arranged such that samples are columns, and</span>
<span class="sd">                        bands are rows, with the first column containing the</span>
<span class="sd">                        band center wavelengths in nanometers. At least two</span>
<span class="sd">                        classes must be specified.</span>
<span class="sd">    em_counts=[]      : Either a list of integers specifying how many em</span>
<span class="sd">                        samples to collect from each em class, a single</span>
<span class="sd">                        integer specifying how many samples to take from all</span>
<span class="sd">                        classes, or an empty list (or equivalently None). In</span>
<span class="sd">                        the first case, the length of this list must match</span>
<span class="sd">                        the length of em_csvs. In the first and second case,</span>
<span class="sd">                        the integer 0 means all available samples. An empty</span>
<span class="sd">                        list or None is equivalent to [0]*len(em_csvs).</span>
<span class="sd">    wl_ranges=None    : A list or tuple of 2-element lists or tuples of</span>
<span class="sd">                        floats, i.e. [(600.0,750),(2030,2380)], that will be</span>
<span class="sd">                        used to identify the band ranges used for unmixing.</span>
<span class="sd">                        Data from the bands specified by these wavelengths</span>
<span class="sd">                        will be lumped into a single array for fitting.</span>
<span class="sd">                        A minimum of one band window must be specified.</span>
<span class="sd">    band_ranges=None  : Similar to band_ranges, but specifying starting and</span>
<span class="sd">                        ending integer band indexes (first band is band 0)</span>
<span class="sd">                        for whatever image this is applied on.</span>
<span class="sd">    tied=True         : Reflectance spectra from each band range are</span>
<span class="sd">                        subtracted from the first value in the window to</span>
<span class="sd">                        help relieve brightness issues. (First value in</span>
<span class="sd">                        unmixing array becomes 0.0 for each windows start)</span>
<span class="sd">    divide=False      : Similar to tied, but window values are dividied by</span>
<span class="sd">                        the first entry. (First value in each window will</span>
<span class="sd">                        become 1.0)</span>
<span class="sd">    shade=False       : Add an endmember for shade, which is constant 0.0</span>
<span class="sd">    sum_to_one=True   : Add an element with value 1.0 to the end of the</span>
<span class="sd">                        unmixing array and the input refl to help coerce sums</span>
<span class="sd">                        of the endmember fractions to be near 1.0.</span>
<span class="sd">    iterations=30     : How many MC runs to do for each pixel.</span>
<span class="sd">    outscale=1000     : Scale value applied to unmixing results to make them</span>
<span class="sd">                        fit into data type specified for output.</span>
<span class="sd">    nodata=-9999      : Output no data value written into metadata. If None,</span>
<span class="sd">                        missing data in output will be 0, but this will not</span>
<span class="sd">                        be recorded in metadata.</span>
<span class="sd">    dtype=&quot;int16&quot;     : Rasterio-usable specification of output map data type.</span>
<span class="sd">    otype=&quot;GTiff&quot;     : GDAL shortname for output data format.</span>
<span class="sd">    co=[]             : GDAL data format writing options.</span>
<span class="sd">    emfwhm=False      : Assume second column of em csvs are fwhm values</span>
<span class="sd">    nointerp=False    : Assume em csvs have same count and wavelengths as</span>
<span class="sd">                        input reflectance data (will be checked)</span>
<span class="sd">    match_c           : Recreate a bug in original C code that shifted input</span>
<span class="sd">                        reflectance data by one index/band</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">em_csvs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">em_counts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">em_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">band_ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wl_ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">divide</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">shade</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">soil_frac</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sum_to_one</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">outscale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">nodata</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span>
        <span class="n">otype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
        <span class="n">co</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">emfwhm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nointerp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">match_c</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">##Check inputs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">tied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">divide</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shade</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">shade</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soilfrac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">soil_frac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_to_one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">iterations</span>  <span class="c1"># defined by user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outscale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">outscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">otype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">otype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dointerp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">nointerp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_c</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dopt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>

        <span class="c1">##Filled later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">##Check the endmember args</span>
        <span class="c1">##########################</span>
        <span class="c1"># em_csv should be a list</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="c1"># For now, lets say em classes should be 2 or more</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="c1"># Counts should either be an empty, a single integer, or a list of</span>
        <span class="c1"># integers the same size as em_csvs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">em_counts</span><span class="p">:</span>
            <span class="n">em_counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">em_counts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">em_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">em_counts</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">)</span>
        <span class="c1"># Check that files exist</span>
        <span class="k">for</span> <span class="n">csv</span> <span class="ow">in</span> <span class="n">em_csvs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">csv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_wl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_fwhm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">csv</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">em_csvs</span><span class="p">,</span> <span class="n">em_counts</span><span class="p">):</span>
            <span class="c1">##Here csv should be formatted with a header row and samples listed</span>
            <span class="c1">## in columns, bands as rows. Wl should be the first columns, and</span>
            <span class="c1">## if --emfwhm is specified, fwhm should be column 2</span>
            <span class="n">tmpdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ems_wl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
            <span class="n">st</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">emfwhm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ems_fwhm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
                <span class="n">st</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ems_fwhm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">maxcount</span> <span class="o">=</span> <span class="n">tmpdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxcount</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">maxcount</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">count</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> samples from </span><span class="si">{</span><span class="n">csv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">st</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading all samples of </span><span class="si">{</span><span class="n">csv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">st</span><span class="p">:]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Save the number of em classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span><span class="p">)</span>

        <span class="c1">##Check for em_names</span>
        <span class="k">if</span> <span class="n">em_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span> <span class="o">=</span> <span class="n">em_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Class</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shade</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Shade&quot;</span><span class="p">)</span>

        <span class="c1">##Check the specified ranges</span>
        <span class="c1">############################</span>
        <span class="c1"># One and only one should be not None</span>
        <span class="k">if</span> <span class="n">band_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># There should be at least one window</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># If the first element is a float, then assume only one range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_ranges</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">band_ranges</span><span class="p">]</span>
            <span class="c1"># Test that all range entries can be floats</span>
            <span class="k">for</span> <span class="n">pr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">pr</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">RuntimeException</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Window range entry </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> could not be converted to int&quot;</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid window range entry: </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">wl_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># There should be at least one window</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wl_ranges</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wl_ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wl_ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># If the first element is a float, then assume only one range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">wl_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wl_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">wl_ranges</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">wl_ranges</span><span class="p">]</span>
            <span class="c1"># Test that all range entries can be floats</span>
            <span class="k">for</span> <span class="n">pr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">pr</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">RuntimeException</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Window range entry </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> could not be converted to float&quot;</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid window range entry: </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s2">&quot;One of wl_ranges or band_ranges must be specified&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_find_hdr_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find the name of the hdr file associated with the input img file</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath (str): The filepath of the input img file</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The filepath of the hdr file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inhdr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">##Go through common hdr name practices looking for one that exists</span>
        <span class="n">inhdropts</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.hdr&quot;</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s2">&quot;.hdr&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">inhdropts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">opt</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found input hdr file at </span><span class="si">{</span><span class="n">opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">inhdr</span> <span class="o">=</span> <span class="n">opt</span>
                <span class="k">break</span>
        <span class="c1">##Will be None if no options exist</span>
        <span class="k">return</span> <span class="n">inhdr</span>

<div class="viewcode-block" id="AutoMCU.interpolate_ems"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.interpolate_ems">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_ems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate end member spectra to the specified wavelengths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wl : array-like</span>
<span class="sd">            Wavelengths to interpolate to. Should be in the same units as</span>
<span class="sd">            self._ems_wl.</span>
<span class="sd">        fwhm : array-like or None</span>
<span class="sd">            FWHM to use for the interpolation. If None, the average spacing of</span>
<span class="sd">            `wl` will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">avg_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="n">avg_spacing</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rawmat</span><span class="p">,</span> <span class="n">rawwl</span><span class="p">,</span> <span class="n">rawfwhm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_wl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_fwhm</span><span class="p">):</span>
            <span class="c1">##Build fwhm if needed</span>
            <span class="k">if</span> <span class="n">rawfwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">avg_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rawwl</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">rawfwhm</span> <span class="o">=</span> <span class="p">[</span><span class="n">avg_spacing</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">rawwl</span><span class="p">)</span>
            <span class="c1">##Interpolate</span>
            <span class="n">brs</span> <span class="o">=</span> <span class="n">spectral</span><span class="o">.</span><span class="n">BandResampler</span><span class="p">(</span><span class="n">rawwl</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">rawfwhm</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">brs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rawmat</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span>  <span class="c1">##Elahe is this correct?</span></div>

<div class="viewcode-block" id="AutoMCU.average_interpolated_ems"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.average_interpolated_ems">[docs]</a>    <span class="k">def</span> <span class="nf">average_interpolated_ems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;interpolated_ems() has not been called yet&quot;</span><span class="p">)</span>
        <span class="n">use_bands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="p">:</span>
            <span class="n">use_bands</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">emarr</span><span class="p">[:,</span> <span class="n">use_bands</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">emarr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AutoMCU.make_unmixing_array"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.make_unmixing_array">[docs]</a>    <span class="k">def</span> <span class="nf">make_unmixing_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">match_c</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select correct bands from arr, a NxB array, where n is number of</span>
<span class="sd">        samples and B is number of bands, and perform tying or dividing if</span>
<span class="sd">        requested&quot;&quot;&quot;</span>
        <span class="n">dat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[:,</span> <span class="n">bandlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">bandlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">dat_list</span><span class="p">:</span>
                <span class="n">dat</span> <span class="o">/=</span> <span class="n">dat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">dat_list</span><span class="p">:</span>
                <span class="n">dat</span> <span class="o">-=</span> <span class="n">dat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">dat_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">)</span>
        <span class="c1">##Bug in automcu.c makes Y(a.k.a., b) data shifted by one index</span>
        <span class="c1">## This results in first band being omitted, and lastband being 0, since</span>
        <span class="c1">##  fsubimgslice array is 0 after last svd band:</span>
        <span class="c1">##   /* This is a bug since fsubimgslice is 0-based indexing, and it  */</span>
        <span class="c1">##   /*     should be fsubimgslice[i][k-1] */</span>
        <span class="c1">##   for (k=1; k&lt;=num_prim_imgbands; k++) imgspec[k] = fsubimgslice[i][k];</span>
        <span class="c1">##</span>
        <span class="c1">##   if (sum_to_one == TRUE) imgspec[num_prim_svdbands] = 1.0;</span>
        <span class="c1">## Re-enact this bug if requested</span>
        <span class="k">if</span> <span class="n">match_c</span><span class="p">:</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">)</span>
            <span class="n">dat</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">dat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dat</span></div>

<div class="viewcode-block" id="AutoMCU.process_iterpolated_ems"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.process_iterpolated_ems">[docs]</a>    <span class="k">def</span> <span class="nf">process_iterpolated_ems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With em data now matching application bands, process for unmixing&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;interpolate_ems() has not been called yet&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dat_i</span><span class="p">,</span> <span class="n">dat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span><span class="p">):</span>
            <span class="n">procdat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_unmixing_array</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
            <span class="c1">##BandResampler returns NaN for wl with no overlap</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">procdat</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Processed em data contains non-finite values&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">procdat</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_random_unmixing_libs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to pick n random samples from the EMs_proc list</span>
<span class="sd">        and stack them together to form a tensor of size n x num_class x num_bands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">s</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="p">:][</span>
                    <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">picks</span>  <span class="c1"># n x num_class x num_bands</span>

<div class="viewcode-block" id="AutoMCU.unmix_array"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.unmix_array">[docs]</a>    <span class="k">def</span> <span class="nf">unmix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Actually do the unmixing for an array of valid refl data of shape</span>
<span class="sd">        N x B, where N is number of samples and B is number of raw spectral</span>
<span class="sd">        bands&quot;&quot;&quot;</span>

        <span class="c1">##Will use pseudoinverse to linearly solve Y = X*coef</span>
        <span class="c1">##Done for all samples simultaneously thanks to numpy magic</span>

        <span class="c1">##Check that some members are not None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;process_interpolated_ems() has not been called yet&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;average_interpolated_ems() has not been called yet&quot;</span><span class="p">)</span>

        <span class="c1">#########################</span>
        <span class="c1">##Prepare Y array (N x B)</span>
        <span class="c1">#########################</span>

        <span class="c1">##Process data in to unmixing array by applying tieing/dividing/sum1</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_unmixing_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_c</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">sample_axis</span><span class="p">]</span>
        <span class="n">num_bands</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">band_axis</span><span class="p">]</span>
        <span class="c1"># Y is shape (num_samples, num_bands)</span>

        <span class="c1">##Also get original refl spectrum for the selected bands</span>
        <span class="c1">##Shape (num_samples, num_bands)</span>
        <span class="n">Yorig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">arr</span><span class="p">[:,</span> <span class="n">bandlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">bandlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span>
        <span class="p">)</span>

        <span class="c1">######################################################</span>
        <span class="c1">##Prepare X matrices from randomly selected endmembers</span>
        <span class="c1">######################################################</span>

        <span class="c1">##Collect needed number of random draws from SPECs</span>
        <span class="c1">## One randomly-selected sample from each class for each iteration for</span>
        <span class="c1">##    each sample</span>
        <span class="c1">##shape (num_samples, self.niter, num_class, num_bands)</span>
        <span class="c1">######################################################################</span>
        <span class="n">random_selections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_unmixing_libs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">*</span> <span class="n">num_samples</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span><span class="p">,</span> <span class="n">num_bands</span><span class="p">)</span>

        <span class="c1">#################</span>
        <span class="c1">##Do the unmixing</span>
        <span class="c1">#################</span>

        <span class="c1">##Collect pseudo_inverses into a new array</span>
        <span class="c1"># shape (num_samples, self.niter, num_bands, num_class)</span>
        <span class="c1">####################################################</span>
        <span class="n">pinvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">random_selections</span><span class="p">)</span>

        <span class="c1">##Get optimal coefficients for each sample and iteration</span>
        <span class="c1">########################################################</span>
        <span class="c1"># shape num_samples, self.niter, num_class)</span>
        <span class="c1">########################################################</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pinvs</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:])[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span><span class="p">)</span>

        <span class="c1">#######################</span>
        <span class="c1">##Compute trimmed stats</span>
        <span class="c1">#######################</span>

        <span class="c1">##Compute quantiles across just iterations</span>
        <span class="c1">## Each is shape (num_samples, num_class)</span>
        <span class="c1">##########################################</span>
        <span class="n">q10</span><span class="p">,</span> <span class="n">q90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">##Trim 10% of coefs from each end by sample and class</span>
        <span class="c1">#####################################################</span>
        <span class="n">coefs</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">coefs</span> <span class="o">&lt;</span> <span class="n">q10</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coefs</span> <span class="o">&gt;</span> <span class="n">q90</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1">##Compute mean and stdev of middle 80%</span>
        <span class="c1">## each shape (num_samples, num_class)</span>
        <span class="c1">######################################</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">)</span>  <span class="c1"># num_samples x num_class</span>
        <span class="n">sds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">)</span>  <span class="c1"># num_samples x num_class</span>

        <span class="c1">######################################################################</span>
        <span class="c1">##Remix expected spectra for each sample and compute sample-level RMSE</span>
        <span class="c1">######################################################################</span>

        <span class="c1">##Build mixed spectra (in original refl scale for selected bands)</span>
        <span class="c1">##(num_samples, num_class)  (num_class, num_bands) =</span>
        <span class="c1">##  (num_samples, num_bands)</span>
        <span class="c1">##  Does not include band of 1s from sum1</span>
        <span class="c1">#################################################################</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span><span class="p">)</span>

        <span class="c1">##RMSE</span>
        <span class="c1">## Shape (num_samples)</span>
        <span class="c1">######</span>
        <span class="n">rmses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">preds</span> <span class="o">-</span> <span class="n">Yorig</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_bands</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">means</span><span class="p">,</span> <span class="n">sds</span><span class="p">,</span> <span class="n">rmses</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">band_axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="AutoMCU.apply_image"><a class="viewcode-back" href="../automcu.html#automcu.AutoMCU.apply_image">[docs]</a>    <span class="k">def</span> <span class="nf">apply_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refl_path</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">hdrpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nblocks</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="c1">##Get info from input image</span>
        <span class="c1">###########################</span>

        <span class="c1">## Grab shape and metadata</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">refl_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">inref</span><span class="p">:</span>
            <span class="n">imgshape</span> <span class="o">=</span> <span class="n">inref</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">imgoffset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">outmeta</span> <span class="o">=</span> <span class="n">inref</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">input_blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inref</span><span class="o">.</span><span class="n">block_windows</span><span class="p">())</span>

        <span class="c1">## Modify if we&#39;re not using all blocks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nblocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>  <span class="c1">##Ealhe Change</span>
            <span class="n">input_blocks</span> <span class="o">=</span> <span class="n">input_blocks</span><span class="p">[</span><span class="n">nblocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">nblocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1">##Elahe change</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unmixing image rows within range of: </span><span class="si">{</span><span class="n">nblocks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1">##Elahe change</span>
        <span class="n">minr</span><span class="p">,</span> <span class="n">minc</span> <span class="o">=</span> <span class="n">imgshape</span>
        <span class="n">maxr</span><span class="p">,</span> <span class="n">maxc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w_i</span><span class="p">,</span> <span class="n">wind</span> <span class="ow">in</span> <span class="n">input_blocks</span><span class="p">:</span>
            <span class="n">minr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minr</span><span class="p">,</span> <span class="n">wind</span><span class="o">.</span><span class="n">row_off</span><span class="p">)</span>
            <span class="n">minc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minc</span><span class="p">,</span> <span class="n">wind</span><span class="o">.</span><span class="n">col_off</span><span class="p">)</span>
            <span class="n">maxr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxr</span><span class="p">,</span> <span class="n">wind</span><span class="o">.</span><span class="n">row_off</span> <span class="o">+</span> <span class="n">wind</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">maxc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxc</span><span class="p">,</span> <span class="n">wind</span><span class="o">.</span><span class="n">col_off</span> <span class="o">+</span> <span class="n">wind</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">imgshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxr</span> <span class="o">-</span> <span class="n">minr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxc</span> <span class="o">-</span> <span class="n">minc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">imgoffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">minr</span><span class="p">,</span> <span class="n">minc</span><span class="p">)</span>

        <span class="c1">##Try to find hdr if not specified</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hdrpath</span><span class="p">:</span>
            <span class="n">hdrpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_hdr_name</span><span class="p">(</span><span class="n">refl_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hdrpath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No matching hdr found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">hdrpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HDR </span><span class="si">{</span><span class="n">hdrpath</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>
        <span class="n">input_hdr</span> <span class="o">=</span> <span class="n">spectral</span><span class="o">.</span><span class="n">envi</span><span class="o">.</span><span class="n">read_envi_header</span><span class="p">(</span><span class="n">hdrpath</span><span class="p">)</span>

        <span class="c1">##Get wavelengths from header</span>
        <span class="k">if</span> <span class="s2">&quot;wavelength&quot;</span> <span class="ow">in</span> <span class="n">input_hdr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span> <span class="k">for</span> <span class="n">wl</span> <span class="ow">in</span> <span class="n">input_hdr</span><span class="p">[</span><span class="s2">&quot;wavelength&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find wavelengths in hdr&quot;</span><span class="p">)</span>
        <span class="c1">##Get fwhm from header or build</span>
        <span class="k">if</span> <span class="s2">&quot;fwhm&quot;</span> <span class="ow">in</span> <span class="n">input_hdr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">hm</span><span class="p">)</span> <span class="k">for</span> <span class="n">hm</span> <span class="ow">in</span> <span class="n">input_hdr</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">## If fwhm missing, just assume equivalent to center spacing</span>
            <span class="n">avg_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="n">avg_spacing</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span>

        <span class="c1">##Check that self.wl and self.fwhm lengths match up</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of hdr wavelengths </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span><span class="si">}</span><span class="s2"> != &quot;</span>
                <span class="c1"># &quot;number of fwhm {len(self.fwhm)}&quot; ##Elahe comment this line</span>
            <span class="p">)</span>

        <span class="c1">##Check that number of self.wl is the same as the number of bands</span>
        <span class="n">num_image_bands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_hdr</span><span class="p">[</span><span class="s2">&quot;bands&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_hdr</span><span class="p">[</span><span class="s2">&quot;bands&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of hdr wavelengths </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span><span class="si">}</span><span class="s2"> != &quot;</span>
                <span class="s2">&quot;number of image bands </span><span class="si">{num_image_bands}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1">##Figure out band ranges</span>
        <span class="c1">########################</span>

        <span class="c1">## Build _band_ranges if wl_ranges provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">wlr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wl_ranges</span><span class="p">:</span>
                <span class="n">br</span> <span class="o">=</span> <span class="n">bandwind_from_wls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">,</span> <span class="o">*</span><span class="n">wlr</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">br</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Could not get band indices from wl&quot;</span> <span class="sa">f</span><span class="s2">&quot; range </span><span class="si">{</span><span class="n">wlr</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">br</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Computed band range </span><span class="si">{</span><span class="n">br</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">[</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">[</span><span class="n">br</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; from wavelength window </span><span class="si">{</span><span class="n">wlr</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1">##Convert _band_ranges to lists of indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span><span class="p">)</span><span class="si">}</span><span class="s2"> band regions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">br_i</span><span class="p">,</span> <span class="n">br</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_band_ranges</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">br</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">num_selected_bands</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="k">for</span> <span class="n">rd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regdefs</span><span class="p">])</span>
        <span class="n">num_unmixing_bands</span> <span class="o">=</span> <span class="n">num_selected_bands</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum1</span><span class="p">:</span>
            <span class="n">num_unmixing_bands</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total unmixing bands (incl. sum_to_one): </span><span class="si">{</span><span class="n">num_unmixing_bands</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total unmixing bands: </span><span class="si">{</span><span class="n">num_unmixing_bands</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">##Interpolate and process em libraries for use in building A matrices</span>
        <span class="c1">#####################################################################</span>

        <span class="c1">##Build self._ems_interp</span>
        <span class="c1">##Will create a list of three NxB matrices, each representing one of the</span>
        <span class="c1">## endmember classes. N is the number of samples in the given class and</span>
        <span class="c1">## B is the number of input image bands</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dointerp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_ems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ems_raw</span>

        <span class="c1">##Check that number of bands match</span>
        <span class="k">for</span> <span class="n">emnum</span><span class="p">,</span> <span class="n">emdat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ems_interp</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">emdat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">band_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of bands in interpolated em data&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span><span class="p">[</span><span class="n">emnum</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">emdat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">band_axis</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="s2">&quot; does not match number of image bands&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wl</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

        <span class="c1">##Compute averaged endmembers (must be done before processing)</span>
        <span class="c1">##############################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">average_interpolated_ems</span><span class="p">()</span>

        <span class="c1">##Build self._ems_proc</span>
        <span class="c1">##Will create a list of three NxB matrices, each representing one of the</span>
        <span class="c1">## endmember classes. N is the number of samples in the given class and</span>
        <span class="c1">## B is the number of unmixing bands (sum of band regions + any extra</span>
        <span class="c1">## for self.sum1 and self.shade)</span>
        <span class="c1">########################################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_iterpolated_ems</span><span class="p">()</span>

        <span class="c1">##Add a single-entry extra class for shade</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shade</span><span class="p">:</span>
            <span class="c1">##Shade is just a row of 0&#39;s</span>
            <span class="n">tmpshade</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_unmixing_bands</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="c1">##Last entry still 1.0 if sum1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum1</span><span class="p">:</span>
                <span class="n">tmpshade</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="c1">##Append it to the _ems_proc list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ems_proc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpshade</span><span class="p">)</span>
            <span class="c1">##Add an average shade to the _em_avg array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_em_avg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_selected_bands</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span>
            <span class="p">)</span>

        <span class="c1">##Prepare output map</span>
        <span class="c1">####################</span>

        <span class="c1">##Update the output meta to match args</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otype</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">:</span>
            <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outmeta</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nodata&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1">##Fix output width and height based on nblocks</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imgshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imgshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">outmeta</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inref</span><span class="o">.</span><span class="n">window_transform</span><span class="p">(</span>
            <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">imgoffset</span><span class="p">),</span> <span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">imgshape</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">output_blocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">w_i</span><span class="p">,</span>
                <span class="n">rasterio</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span>
                    <span class="n">wind</span><span class="o">.</span><span class="n">col_off</span> <span class="o">-</span> <span class="n">imgoffset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">wind</span><span class="o">.</span><span class="n">row_off</span> <span class="o">-</span> <span class="n">imgoffset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">wind</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                    <span class="n">wind</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">w_i</span><span class="p">,</span> <span class="n">wind</span> <span class="ow">in</span> <span class="n">input_blocks</span>
        <span class="p">]</span>

        <span class="c1">##Run AutoMCU by image blocks and write to output</span>
        <span class="c1">#################################################</span>
        <span class="c1">##Zip the input and output blocks so we can iterate over pairs</span>
        <span class="n">comb_blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">input_blocks</span><span class="p">],</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">output_blocks</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">outmeta</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">dopt</span><span class="p">)</span> <span class="k">as</span> <span class="n">oref</span><span class="p">:</span>

            <span class="c1">##Update band descriptions</span>
            <span class="c1">##########################</span>
            <span class="n">banddesc</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span><span class="p">]</span>
            <span class="n">banddesc</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;sd</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_names</span><span class="p">])</span>
            <span class="n">banddesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;RMSE&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band names will be: </span><span class="si">{</span><span class="n">banddesc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">oref</span><span class="o">.</span><span class="n">descriptions</span> <span class="o">=</span> <span class="n">banddesc</span>

            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">refl_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">inref</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">inwind</span><span class="p">,</span> <span class="n">outwind</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">comb_blocks</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing blocks&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">comb_blocks</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1">###############################################</span>
                    <span class="c1">##Read image data and filter out no data pixels</span>
                    <span class="c1">###############################################</span>

                    <span class="c1">##Make output shape tuple and count total block pixels</span>
                    <span class="c1">######################################################</span>
                    <span class="n">out_bands</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_class</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_bands</span><span class="p">,</span> <span class="n">inwind</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">inwind</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                    <span class="n">num_pix</span> <span class="o">=</span> <span class="n">inwind</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">inwind</span><span class="o">.</span><span class="n">width</span>

                    <span class="c1">##Read the data for this block</span>
                    <span class="c1">##############################</span>
                    <span class="n">val_dat</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">inref</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">inwind</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inref</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">input_scale</span>
                    <span class="p">)</span>

                    <span class="c1">##Filter for pixels with constant values across all</span>
                    <span class="c1">## bands (i.e. no data)</span>
                    <span class="c1">###################################################</span>
                    <span class="n">isval</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                        <span class="n">val_dat</span> <span class="o">==</span> <span class="n">val_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="n">sample_axis</span>
                    <span class="p">)</span>
                    <span class="c1">##How many valid pixels in this block window</span>
                    <span class="n">num_valid</span> <span class="o">=</span> <span class="n">isval</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                    <span class="c1">##Drop the nodata pixels</span>
                    <span class="c1">########################</span>
                    <span class="n">val_dat</span> <span class="o">=</span> <span class="n">val_dat</span><span class="p">[:,</span> <span class="n">isval</span><span class="p">]</span>
                    <span class="c1">##Shape (image_bands, num_valid)</span>

                    <span class="c1">###########################################################</span>
                    <span class="c1">##Unmix the valid data</span>
                    <span class="c1">##Returns an array of concatenated mean coefficients, stdev</span>
                    <span class="c1">## coefficients, and rmse</span>
                    <span class="c1">###########################################################</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unmix_array</span><span class="p">(</span><span class="n">val_dat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="c1">##########################</span>
                    <span class="c1">##Prepare and write output</span>
                    <span class="c1">##########################</span>
                    <span class="n">out_dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">out_bands</span><span class="p">,</span> <span class="n">num_pix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
                    <span class="n">out_dat</span><span class="p">[:,</span> <span class="n">isval</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">outscale</span>
                    <span class="n">oref</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_dat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">window</span><span class="o">=</span><span class="n">outwind</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">AutoMCU</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">amcu</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Nick Vaughn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>